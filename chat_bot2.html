<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Morpion avec IA Apprenante</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
        }
        .animate-pulse-slow {
            animation: pulse 3s infinite;
        }
        .board-cell {
            transition: all 0.3s ease;
        }
        .board-cell:hover {
            transform: scale(1.05);
        }
        .shadow-glow {
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
        }
    </style>
</head>
<body class="bg-gray-900 min-h-screen flex flex-col items-center justify-center text-white font-sans">
    <div class="container mx-auto px-4 py-8 flex flex-col items-center">
        <h1 class="text-4xl md:text-5xl font-bold mb-6 text-center bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-600">
            Morpion Évolutif
        </h1>
        <p class="text-lg text-gray-300 mb-8 max-w-2xl text-center">
            Jouez contre une IA qui apprend de vos mouvements. Plus vous jouez, plus elle devient intelligente!
        </p>

        <div class="flex flex-col md:flex-row gap-8 w-full max-w-6xl">
            <!-- Board Section -->
            <div class="flex-1">
                <div id="board" class="grid grid-cols-3 gap-4 w-full max-w-md mx-auto mb-6">
                    <!-- Cells will be generated by JavaScript -->
                </div>
                
                <div class="flex justify-center gap-4 mb-8">
                    <button id="reset-btn" class="px-6 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg font-medium transition-all duration-300 flex items-center gap-2">
                        <i class="fas fa-sync-alt"></i> Nouvelle Partie
                    </button>
                    <button id="toggle-ai" class="px-6 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg font-medium transition-all duration-300 flex items-center gap-2">
                        <i class="fas fa-robot"></i> IA Active
                    </button>
                    <select id="ai-type" class="px-3 py-2 bg-gray-700 rounded-lg font-medium">
                        <option value="minimax">Minimax (Difficile)</option>
                        <option value="random">Aléatoire (Facile)</option>
                        <option value="learning">Apprenante</option>
                        <option value="defensive">Défensive</option>
                    </select>
                </div>
            </div>

            <!-- Stats Section -->
            <div class="flex-1 bg-gray-800 rounded-xl p-6 shadow-lg">
                <h2 class="text-2xl font-bold mb-4 flex items-center gap-2 text-blue-400">
                    <i class="fas fa-chart-line"></i> Statistiques
                </h2>
                
                <div class="grid grid-cols-2 gap-4 mb-6">
                    <div class="bg-gray-700 p-4 rounded-lg">
                        <h3 class="text-gray-300 text-sm">Parties jouées</h3>
                        <p id="games-played" class="text-3xl font-bold">0</p>
                    </div>
                    <div class="bg-gray-700 p-4 rounded-lg">
                        <h3 class="text-gray-300 text-sm">Taux de victoire IA</h3>
                        <p id="ai-win-rate" class="text-3xl font-bold">0%</p>
                    </div>
                    <div class="bg-gray-700 p-4 rounded-lg">
                        <h3 class="text-gray-300 text-sm">Niveau IA</h3>
                        <p id="ai-level" class="text-3xl font-bold">Novice</p>
                    </div>
                    <div class="bg-gray-700 p-4 rounded-lg">
                        <h3 class="text-gray-300 text-sm">Mémoire IA</h3>
                        <p id="ai-memory" class="text-3xl font-bold">0</p>
                    </div>
                </div>

                <div class="bg-gray-700 p-4 rounded-lg">
                    <h3 class="text-gray-300 text-sm mb-2">Historique</h3>
                    <div id="history" class="text-sm text-gray-200 h-32 overflow-y-auto">
                        <p class="py-1 border-b border-gray-600">Bienvenue! Commencez une nouvelle partie.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="mt-8 text-gray-400 text-sm">
        <p>L'IA s'améliore après chaque partie en mémorisant les positions gagnantes.</p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game state
            let board = ['', '', '', '', '', '', '', '', ''];
            let currentPlayer = 'X'; // Human is X, AI is O
            let gameActive = true;
            let aiEnabled = true;
            let aiType = 'minimax'; // Default AI type
            let gamesPlayed = 0;
            let aiWins = 0;
            let aiLosses = 0;
            let aiDraws = 0;
            
            // AI Memory
            let aiMemory = new Map();
            
            // DOM elements
            const boardElement = document.getElementById('board');
            const resetBtn = document.getElementById('reset-btn');
            const toggleAiBtn = document.getElementById('toggle-ai');
            const gamesPlayedElement = document.getElementById('games-played');
            const aiWinRateElement = document.getElementById('ai-win-rate');
            const aiLevelElement = document.getElementById('ai-level');
            const aiMemoryElement = document.getElementById('ai-memory');
            const historyElement = document.getElementById('history');
            
            // Initialize the board
            function initializeBoard() {
                boardElement.innerHTML = '';
                for (let i = 0; i < 9; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'board-cell bg-gray-800 h-24 md:h-32 flex items-center justify-center text-4xl md:text-5xl font-bold rounded-lg cursor-pointer hover:bg-gray-700 transition-colors duration-200';
                    cell.dataset.index = i;
                    cell.addEventListener('click', () => handleCellClick(i));
                    boardElement.appendChild(cell);
                }
            }
            
            // Handle cell click
            function handleCellClick(index) {
                if (!gameActive || board[index] !== '' || (!aiEnabled && currentPlayer === 'O')) return;
                
                // Human move
                makeMove(index, 'X');
                
                if (gameActive && aiEnabled && currentPlayer === 'O') {
                    setTimeout(() => {
                        const aiMove = getBestMove();
                        makeMove(aiMove, 'O');
                    }, 500);
                }
            }
            
            // Make a move
            function makeMove(index, player) {
                board[index] = player;
                updateBoard();
                
                if (checkWinner()) {
                    gameActive = false;
                    const winner = player === 'X' ? 'Vous' : 'IA';
                    addHistory(`${winner} avez gagné!`);
                    
                    if (player === 'O') {
                        aiWins++;
                        learnFromGame(1); // AI won, reinforce its moves
                    } else {
                        aiLosses++;
                        learnFromGame(-1); // AI lost, penalize its moves
                    }
                    
                    gamesPlayed++;
                    updateStats();
                    return;
                }
                
                if (isBoardFull()) {
                    gameActive = false;
                    aiDraws++;
                    gamesPlayed++;
                    updateStats();
                    addHistory('Match nul!');
                    learnFromGame(0); // Draw, slight reinforcement for defensive moves
                    return;
                }
                
                currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                
                // Add visual indication for whose turn it is
                const turnIndicator = document.createElement('div');
                turnIndicator.className = 'absolute top-2 right-2 text-xs font-bold';
                turnIndicator.textContent = `Tour: ${currentPlayer === 'X' ? 'Vous' : 'IA'}`;
                document.querySelectorAll('.board-cell').forEach(cell => {
                    const existing = cell.querySelector('.turn-indicator');
                    if (existing) cell.removeChild(existing);
                });
            }
            
            // Update board display
            function updateBoard() {
                const cells = document.querySelectorAll('.board-cell');
                cells.forEach((cell, index) => {
                    cell.innerHTML = '';
                    if (board[index] !== '') {
                        const symbol = document.createElement('div');
                        symbol.className = `inline-block ${
                            board[index] === 'X' 
                                ? 'text-blue-400 animate-pulse-slow' 
                                : 'text-purple-400 animate-pulse-slow'
                        }`;
                        symbol.innerHTML = board[index] === 'X' 
                            ? '<i class="fas fa-times"></i>' 
                            : '<i class="far fa-circle"></i>';
                        cell.appendChild(symbol);
                    }
                });
            }
            
            // Check for winner
            function checkWinner() {
                const winPatterns = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
                    [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
                    [0, 4, 8], [2, 4, 6]             // diagonals
                ];
                
                return winPatterns.some(pattern => {
                    const [a, b, c] = pattern;
                    return board[a] !== '' && board[a] === board[b] && board[a] === board[c];
                });
            }
            
            // Check if board is full
            function isBoardFull() {
                return board.every(cell => cell !== '');
            }
            
            // Different AI strategies
            function getRandomMove() {
                const emptyCells = board.map((cell, index) => cell === '' ? index : null).filter(val => val !== null);
                return emptyCells[Math.floor(Math.random() * emptyCells.length)];
            }

            function getDefensiveMove() {
                const emptyCells = board.map((cell, index) => cell === '' ? index : null).filter(val => val !== null);
                
                // Try to block opponent first
                for (let i = 0; i < emptyCells.length; i++) {
                    const index = emptyCells[i];
                    board[index] = 'X';
                    if (checkWinner()) {
                        board[index] = '';
                        return index;
                    }
                    board[index] = '';
                }
                
                // Otherwise random move
                return getRandomMove();
            }

            // Main AI move selector
            function getBestMove() {
                switch(aiType) {
                    case 'random':
                        return getRandomMove();
                    case 'defensive':
                        return getDefensiveMove();
                    case 'learning':
                        return getLearningMove();
                    default:
                        return getMinimaxMove();
                }
            }

            // Minimax AI
            function getMinimaxMove() {
                const emptyCells = board.map((cell, index) => cell === '' ? index : null).filter(val => val !== null);
                
                // If board is empty, return center or random corner for better start
                if (emptyCells.length === 9) {
                    return Math.random() < 0.7 ? 4 : [0, 2, 6, 8][Math.floor(Math.random() * 4)];
                }
                
                // Check memory for known positions
                const boardKey = board.join('');
                if (aiMemory.has(boardKey)) {
                    const memoryMove = aiMemory.get(boardKey);
                    if (board[memoryMove] === '') {
                        return memoryMove;
                    }
                }
                
                // If AI can win in one move, take it
                for (let i = 0; i < emptyCells.length; i++) {
                    const index = emptyCells[i];
                    board[index] = 'O';
                    if (checkWinner()) {
                        board[index] = '';
                        return index;
                    }
                    board[index] = '';
                }
                
                // If human can win in next move, block it
                for (let i = 0; i < emptyCells.length; i++) {
                    const index = emptyCells[i];
                    board[index] = 'X';
                    if (checkWinner()) {
                        board[index] = '';
                        return index;
                    }
                    board[index] = '';
                }
                
                // Use Minimax to find best move
                let bestScore = -Infinity;
                let bestMove = null;
                
                for (let i = 0; i < emptyCells.length; i++) {
                    const index = emptyCells[i];
                    board[index] = 'O';
                    const score = minimax(board, 0, false, -Infinity, Infinity);
                    board[index] = '';
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = index;
                    }
                }
                
                return bestMove;
            }
            
            // Minimax algorithm with alpha-beta pruning
            function minimax(board, depth, isMaximizing, alpha, beta) {
                if (checkWinner()) {
                    return isMaximizing ? -10 + depth : 10 - depth;
                }
                
                if (isBoardFull()) {
                    return 0;
                }
                
                if (isMaximizing) {
                    let bestScore = -Infinity;
                    for (let i = 0; i < 9; i++) {
                        if (board[i] === '') {
                            board[i] = 'O';
                            const score = minimax(board, depth + 1, false, alpha, beta);
                            board[i] = '';
                            bestScore = Math.max(score, bestScore);
                            alpha = Math.max(alpha, bestScore);
                            if (beta <= alpha) break;
                        }
                    }
                    return bestScore;
                } else {
                    let bestScore = Infinity;
                    for (let i = 0; i < 9; i++) {
                        if (board[i] === '') {
                            board[i] = 'X';
                            const score = minimax(board, depth + 1, true, alpha, beta);
                            board[i] = '';
                            bestScore = Math.min(score, bestScore);
                            beta = Math.min(beta, bestScore);
                            if (beta <= alpha) break;
                        }
                    }
                    return bestScore;
                }
            }
            
            // AI learning from game results
            function learnFromGame(result) {
                const boardKey = board.join('');
                
                // Simple reinforcement learning - remember winning moves
                if (result === 1) { // AI won
                    // Find all AI moves (O) in this game
                    board.forEach((cell, index) => {
                        if (cell === 'O') {
                            const partialKey = board.map((c, i) => i === index ? '' : c).join('');
                            aiMemory.set(partialKey, index);
                        }
                    });
                }
                
                // Alternatively, we could store the entire game sequence with weights
                // This is a simplified version for demonstration
            }
            
            // Update statistics
            function updateStats() {
                gamesPlayedElement.textContent = gamesPlayed;
                const winRate = gamesPlayed > 0 ? Math.round((aiWins / gamesPlayed) * 100) : 0;
                aiWinRateElement.textContent = `${winRate}%`;
                aiMemoryElement.textContent = aiMemory.size;
                
                // Determine AI level based on performance
                let level = 'Novice';
                if (gamesPlayed >= 5) {
                    if (winRate >= 70) level = 'Expert';
                    else if (winRate >= 40) level = 'Intermédiaire';
                    else level = 'Débutant';
                }
                aiLevelElement.textContent = level;
            }
            
            // Add to history
            function addHistory(message) {
                const entry = document.createElement('p');
                entry.className = 'py-1 border-b border-gray-600';
                
                const timestamp = new Date().toLocaleTimeString();
                entry.textContent = `[${timestamp}] ${message}`;
                
                historyElement.insertBefore(entry, historyElement.firstChild);
                
                // Limit history size
                if (historyElement.children.length > 10) {
                    historyElement.removeChild(historyElement.lastChild);
                }
            }
            
            // Reset game
            function resetGame() {
                board = ['', '', '', '', '', '', '', '', ''];
                currentPlayer = 'X';
                gameActive = true;
                updateBoard();
                addHistory('Nouvelle partie commencée.');
            }
            
            // AI event handlers
            function toggleAI() {
                aiEnabled = !aiEnabled;
                updateAIUI();
            }
            
            function changeAIType() {
                aiType = document.getElementById('ai-type').value;
                addHistory(`Changement d'IA: ${document.getElementById('ai-type').options[document.getElementById('ai-type').selectedIndex].text}`);
                updateAIUI();
            }
            
            function updateAIUI() {
                toggleAiBtn.innerHTML = aiEnabled 
                    ? '<i class="fas fa-robot"></i> IA Active' 
                    : '<i class="fas fa-robot"></i> IA Désactivée';
                toggleAiBtn.className = aiEnabled 
                    ? 'px-6 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg font-medium transition-all duration-300 flex items-center gap-2 shadow-glow' 
                    : 'px-6 py-2 bg-gray-600 hover:bg-gray-700 rounded-lg font-medium transition-all duration-300 flex items-center gap-2';
                addHistory(`IA ${aiEnabled ? 'activée' : 'désactivée'}.`);
                
                if (aiEnabled && currentPlayer === 'O' && gameActive) {
                    setTimeout(() => {
                        const aiMove = getBestMove();
                        makeMove(aiMove, 'O');
                    }, 500);
                }
            }
            
            // Event listeners
            resetBtn.addEventListener('click', resetGame);
            toggleAiBtn.addEventListener('click', toggleAI);
            document.getElementById('ai-type').addEventListener('change', changeAIType);
            
            // Initial setup
            initializeBoard();
            updateStats();
            function goBack() {
      window.location.href = 'hire_me.html';
    }
        });
    </script>
</body>
</html>